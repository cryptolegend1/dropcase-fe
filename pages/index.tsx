import type { NextPage } from "next";
import Head from "next/head";
import Layout from "components/Layout";
import { useQuery } from "@apollo/client";
import {
  Box,
  FormControl,
  InputLabel,
  MenuItem,
  Select,
  Typography,
} from "@mui/material";
import { ethers } from "ethers";
import dropcaseABI from "abi/dropcase.json";
import { useEffect, useState } from "react";
import { useWalletContext, WalletContextType } from "../src/context/wallet";
import {
  useDropcaseContext,
  DropcaseContextType,
} from "../src/context/dropcase";
import { DROPCASE_TOKENS } from "tokenQuery";
import CardMedia from "@mui/material/CardMedia";
import nftABI from "abi/nft.json";
import nftContracts from "config/nftsContracts";

const Home: NextPage = () => {
  const { account, library, network } = useWalletContext() as WalletContextType;
  const [balance, setBalance] = useState(0);
  const { dropcaseTokenIds, setDropcaseTokenIds } =
    useDropcaseContext() as DropcaseContextType;

  const {
    currentDropcaseId,
    setCurrentDropcaseId,
    currentNFTId,
    setCurrentNFTId,
  } = useDropcaseContext() as DropcaseContextType;

  const [nftTokenIds, setNftTokenIds] = useState<number[]>([]);
  const [nfts, setNfts] = useState<number[]>([]);

  useQuery(DROPCASE_TOKENS, {
    variables: {
      contractAddr: process.env.NEXT_PUBLIC_DROPCASE_CONTRACT,
      tokenId: currentDropcaseId,
    },
    skip: !currentDropcaseId,
    onError: () => {
      console.log("error");
    },
    onCompleted: (data) => {
      if (data.genericSmartBaskets.length && library) {
        data.genericSmartBaskets[0].tokenBalances.map(
          async (nftContract: any) => {
            const nfts: any = [];
            await Promise.all(
              nftContract.nftsById.map(async (nft: any) => {
                const contract = new ethers.Contract(
                  nftContract.nftTokenAddress,
                  nftABI,
                  library
                );
                const nftName = await contract.name();
                if (nftContracts.includes(nftContract.nftTokenAddress))
                  nfts.push({
                    contract: nftContract.nftTokenAddress,
                    tokenId: +nft.tokenId,
                    balance: +nft.tokeBalance,
                    name: nftName,
                  });
              })
            );
            setNfts(nfts);
          }
        );
      }
    },
  });

  useEffect(() => {
    (async () => {
      if (
        process.env.NEXT_PUBLIC_DROPCASE_CONTRACT &&
        process.env.NEXT_PUBLIC_CHAIN_ID &&
        account &&
        library &&
        network === +process.env.NEXT_PUBLIC_CHAIN_ID
      ) {
        const contract = new ethers.Contract(
          process.env.NEXT_PUBLIC_DROPCASE_CONTRACT,
          dropcaseABI,
          library
        );
        const balance = (await contract.balanceOf(account)).toNumber();
        setBalance(balance);
        const tokenIds: number[] = [];
        if (balance) {
          for (let i = 0; i < balance; i++) {
            tokenIds.push(
              (await contract.tokenOfOwnerByIndex(account, i)).toNumber()
            );
          }
          setDropcaseTokenIds(tokenIds);
        }
      }
    })();
  }, [account, library]);

  const handleDropCaseChange = (e: any) => {
    setCurrentDropcaseId(+e.target.value);
    setCurrentNFTId(0);
  };

  const handleNFTChange = (e: any) => {
    setCurrentNFTId(+e.target.value);
  };
  return (
    <div>
      <Head>
        <title>MODA DropCase</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main>
        <Layout>
          <Box
            sx={{
              mt: "50px",
              display: "flex",
              alignItems: "center",
              flexDirection: "column",
              gap: "20px",
            }}
          >
            {!account && (
              <Typography variant="h4">Welcome to Dropcase</Typography>
            )}
            {!!account && (
              <Typography variant="h5">
                You have {balance} DropCase(s)
              </Typography>
            )}
            {!!account && !!dropcaseTokenIds.length && (
              <FormControl sx={{ minWidth: 200 }}>
                <InputLabel id="dropcase-select-label">
                  Select DropCase
                </InputLabel>

                <Select
                  defaultValue={""}
                  labelId="dropcase-select-label"
                  id="dropcase-simple-select"
                  value={!currentDropcaseId ? "" : currentDropcaseId.toString()}
                  label="Select DropCase"
                  onChange={handleDropCaseChange}
                >
                  {dropcaseTokenIds.map((id: number, key: number) => (
                    <MenuItem key={key} value={id}>
                      Dropcase {id}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
            )}
            <Box>
              {/* <Box component="img" src="image1.jpg" sx={{ width: "500px" }} /> */}
              <CardMedia
                component={"img"}
                src="dropcase.jpg"
                sx={{ height: "500px" }}
              />

              {!!currentDropcaseId && (
                <Box textAlign={"center"}>
                  <FormControl sx={{ minWidth: 200, mt: "20px" }}>
                    <InputLabel id="nft-select-label">Select NFT</InputLabel>

                    <Select
                      defaultValue={""}
                      labelId="nft-select-label"
                      id="nft-select"
                      value={!currentNFTId ? "" : currentNFTId.toString()}
                      label="Select NFT"
                      onChange={handleNFTChange}
                    >
                      {nfts.map((nft: any, key: number) => (
                        <MenuItem key={key} value={key}>
                          {nft.name} {nft.tokenId}
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Box>
              )}
            </Box>
          </Box>
        </Layout>
      </main>
    </div>
  );
};
export async function getStaticProps() {
  // const { data } = await client.query({
  //   query: gql``,
  // });

  return {
    props: {},
  };
}

export default Home;
