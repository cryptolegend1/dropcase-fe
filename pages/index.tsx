import type { NextPage } from "next";
import Head from "next/head";
import Layout from "components/Layout";
import { useQuery } from "@apollo/client";
import {
  Box,
  FormControl,
  InputLabel,
  MenuItem,
  Select,
  TextField,
  Typography,
} from "@mui/material";
import { ethers } from "ethers";
import dropcaseABI from "abi/dropcase.json";
import { useEffect, useState } from "react";
import { useWalletContext, WalletContextType } from "../src/context/wallet";
import {
  useDropcaseContext,
  DropcaseContextType,
} from "../src/context/dropcase";
import { DROPCASE_TOKENS } from "tokenQuery";
import CardMedia from "@mui/material/CardMedia";
import erc165ABI from "abi/erc165.json";
import nftContracts, { ERC721InterfaceId } from "config/nftsContracts";

const Home: NextPage = () => {
  const { account, library, network } = useWalletContext() as WalletContextType;
  const [balance, setBalance] = useState(0);
  const [amount, setAmount] = useState(1);

  const {
    dropcaseTokenIds,
    setDropcaseTokenIds,
    currentDropcaseId,
    setCurrentDropcaseId,
    currentNFT,
    setCurrentNFT,
    alchemyWeb3,
  } = useDropcaseContext() as DropcaseContextType;

  const [nfts, setNfts] = useState<number[]>([]);
  const [currentNFTIdx, setCurrentNFTIdx] = useState(0);

  useQuery(DROPCASE_TOKENS, {
    variables: {
      contractAddr: process.env.NEXT_PUBLIC_DROPCASE_CONTRACT,
      tokenId: currentDropcaseId,
    },
    skip: !currentDropcaseId,
    onError: () => {
      console.log("error");
    },
    onCompleted: async (data) => {
      if (data.genericSmartBaskets.length && library && alchemyWeb3) {
        const nfts: any = [];
        await Promise.all(
          data.genericSmartBaskets[0].tokenBalances.map(
            async (nftContract: any) => {
              await Promise.all(
                nftContract.nftsById.map(async (nft: any) => {
                  let contract = new ethers.Contract(
                    nftContract.nftTokenAddress,
                    erc165ABI,
                    library
                  );

                  const is721 = await contract.supportsInterface(
                    ERC721InterfaceId
                  );
                  const tokenMetadata =
                    await alchemyWeb3.alchemy.getNftMetadata({
                      contractAddress: nftContract.nftTokenAddress,
                      tokenId: +nft.tokenId,
                      tokenType: is721 ? "erc721" : "erc1155",
                    });

                  if (
                    process.env.NEXT_PUBLIC_CHAIN_ID &&
                    nftContracts[process.env.NEXT_PUBLIC_CHAIN_ID].includes(
                      nftContract.nftTokenAddress
                    )
                  )
                    nfts.push({
                      address: nftContract.nftTokenAddress,
                      tokenId: +nft.tokenId,
                      balance: +nft.tokenBalance,
                      name:
                        tokenMetadata.title ||
                        tokenMetadata.contractMetadata.name,
                      amount: 1,
                      tokeType: is721 ? "erc721" : "erc1155",
                    });
                })
              );
            }
          )
        );
        setNfts(nfts);
      } else {
        setNfts([]);
      }
    },
  });

  useEffect(() => {
    (async () => {
      if (
        process.env.NEXT_PUBLIC_DROPCASE_CONTRACT &&
        process.env.NEXT_PUBLIC_CHAIN_ID &&
        account &&
        library &&
        network === +process.env.NEXT_PUBLIC_CHAIN_ID
      ) {
        const contract = new ethers.Contract(
          process.env.NEXT_PUBLIC_DROPCASE_CONTRACT,
          dropcaseABI,
          library
        );
        const balance = (await contract.balanceOf(account)).toNumber();
        setBalance(balance);
        const tokenIds: number[] = [];
        if (balance) {
          for (let i = 0; i < balance; i++) {
            tokenIds.push(
              (await contract.tokenOfOwnerByIndex(account, i)).toNumber()
            );
          }
          setDropcaseTokenIds(tokenIds);
        }
      }
    })();
  }, [account, library]);

  const handleDropCaseChange = (e: any) => {
    setCurrentDropcaseId(+e.target.value);
    setCurrentNFT(null);
  };

  const handleNFTChange = (e: any) => {
    setCurrentNFTIdx(+e.target.value);
    setAmount(1);
    setCurrentNFT(nfts[+e.target.value - 1]);
  };
  return (
    <div>
      <Head>
        <title>MODA DropCase</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main>
        <Layout>
          <Box
            sx={{
              mt: "50px",
              display: "flex",
              alignItems: "center",
              flexDirection: "column",
              gap: "20px",
            }}
          >
            {!account && (
              <Typography variant="h4">Welcome to Dropcase</Typography>
            )}
            {!!account && (
              <Typography variant="h5">
                You have {balance} DropCase(s)
              </Typography>
            )}
            {!!account && !!dropcaseTokenIds.length && (
              <FormControl sx={{ minWidth: 200 }}>
                <InputLabel id="dropcase-select-label">
                  Select DropCase
                </InputLabel>

                <Select
                  defaultValue={""}
                  labelId="dropcase-select-label"
                  id="dropcase-simple-select"
                  value={!currentDropcaseId ? "" : currentDropcaseId.toString()}
                  label="Select DropCase"
                  onChange={handleDropCaseChange}
                >
                  {dropcaseTokenIds.map((id: number, key: number) => (
                    <MenuItem key={key} value={id}>
                      Dropcase {id}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
            )}
            <Box>
              <CardMedia
                component={"img"}
                src="dropcase.jpg"
                sx={{ height: "500px", width: "571px" }}
              />

              {!!currentDropcaseId && (
                <Box textAlign={"center"}>
                  <FormControl sx={{ minWidth: 200, mt: "20px" }}>
                    <InputLabel id="nft-select-label">Select NFT</InputLabel>

                    <Select
                      defaultValue={""}
                      labelId="nft-select-label"
                      id="nft-select"
                      value={!currentNFTIdx ? "" : currentNFTIdx.toString()}
                      label="Select NFT"
                      onChange={handleNFTChange}
                    >
                      {nfts.map((nft: any, key: number) => (
                        <MenuItem key={key} value={key + 1}>
                          {nft.name} #{nft.tokenId} (balance: {nft.balance})
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                  <FormControl sx={{ width: 80, mt: "20px", ml: "20px" }}>
                    {!!currentNFT && (
                      <TextField
                        id="amount"
                        label="Amount"
                        variant="outlined"
                        value={amount}
                        type="number"
                        inputProps={{ min: 1, max: currentNFT.balance }}
                        onChange={(e: any) => {
                          setAmount(e.target.value);
                          setCurrentNFT({
                            ...currentNFT,
                            amount: +e.target.value,
                          });
                        }}
                      />
                    )}
                  </FormControl>
                </Box>
              )}
            </Box>
          </Box>
        </Layout>
      </main>
    </div>
  );
};
export async function getStaticProps() {
  // const { data } = await client.query({
  //   query: gql``,
  // });

  return {
    props: {},
  };
}

export default Home;
